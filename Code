dimport numpy as np
import matplotlib.pyplot as plt
import math

def perlinPixel(neighbours : tuple):
    #structure of neighbours: [x position, y position][x magnitude, y magnitude]
    #for each point, generate a vector between the XY position of the centre of the pixel and the origin of the vector
    #dot product each set of 2 vectors
    #interpolate/average
    #return value between 0 and 1
    pass


def pointVector(xCount : int, yCount : int, seed : int):
    pointVectors = np.zeros((xCount,yCount,2), dtype=float) 
    #initialise the list

    rng = np.random.default_rng(seed)
    #seed the random function

    for x in range(xCount):
        for y in range(yCount):
            angle = rng.random() * 2 * math.pi 
            #generate a value between 0 and 2pi radians

            pointVectors[x,y] = [math.sin(angle), math.cos(angle)]
            #convert to cartesian and assign

    #return list of cartesian magnitudes [x magnitude, y magnitude]
    return pointVectors

def pointGeneration(gridRandomisation, minX, maxX, minY, maxY, xCount : int, yCount : int, seed : int):
    xSpan = maxX - minX
    ySpan = maxY - minY
    #find X and Y span

    spacingX = xSpan / xCount
    spacingY = ySpan / yCount

    pointCoords = np.zeros((xCount,yCount,2), dtype=float) 
    #initialise the list

    for x in range(xCount):
        for y in range(yCount):
            pointCoords[x,y] = [(x * spacingX) + minX , (y * spacingY) + minY]
    #generate X points and duplicate Y times
    
    if gridRandomisation == 0:
        return pointCoords

    rng = np.random.default_rng(seed) # seed the random fucntion
    
    #randomise points
    for x in range(xCount):
        for y in range(yCount):
            pointCoords[x,y,0] += ((rng.random() * 2) - 1) * gridRandomisation * spacingX 
            pointCoords[x,y,1] += ((rng.random() * 2) - 1) * gridRandomisation * spacingY 
            #multiplying by 2 and subtracting 1 increases the span of the float generator from 0-1 to -1 - 1 

    #iterate through every coordinate and randomise XY

    return pointCoords

def perlinNoise(gridRandomisation, minX, maxX, minY, maxY, xCount, yCount, seed : int):

    pointCoords = pointGeneration(gridRandomisation, minX, maxX, minY, maxY, xCount, yCount, seed)
    #structure [x position, y position]
    pointVectors = pointVector(xCount, yCount, seed)
    #structure [x magnitude, y magnitude]



    bitmap = perlinPixel()

    return bitmap

gridRandomisation = 1 #GUI slider between 0 and 1
minX = -5
maxX = 5
minY = -5
maxY = 5
xCount = 25 #integer gui slider between 1 and 1000
yCount = 25 #integer gui slider between 1 and 1000
seed = 0 #integer text box - possibility of adding hash functionality
#option of adding a black level and a white level

#perlinNoise(gridRandomisation, minX, maxX, minY, maxY, xCount, yCount, seed)


pointCoords = pointGeneration(gridRandomisation, minX, maxX, minY, maxY, xCount, yCount, seed)
pointVectors = pointVector(xCount, yCount, seed)

xcoords = []
ycoords = []
xMags = []
yMags = []

for x in range(pointCoords.shape[0]):
    for y in range(pointCoords.shape[1]):
        xcoords.append(pointCoords[x,y,0])
        ycoords.append(pointCoords[x,y,1])
        xMags.append(pointVectors[x,y,0])
        yMags.append(pointVectors[x,y,1])


#print("xvalues", array[0], "\n", "yvalues", array[1] )

#plt.scatter(xcoords,ycoords)
plt.quiver(xcoords,ycoords, xMags, yMags)
plt.show()
