import numpy as np
import matplotlib.pyplot as plt
import math
from time import perf_counter
from PIL import Image

def lerp(a : float, b : float, c : float):
    assert c >= 0 and c <= 1
    return (b - a) * c + a

def smooth(v):
    assert v >= 0 and v <= 1
    outputValue = v * v * v * (6 * v * v - 15 * v + 10 )
    assert outputValue <= 1 and outputValue >= 0
    return outputValue

def perlinPixel(xPixel, yPixel, pointPositions, pixelPosition):
    #perlinpixel uses the pixel based coordinate system
    #structure of pointPositions: [x position, y position],[x magnitude, y magnitude]
    #order: [bottomLeft, topLeft, bottomRight, topRight]
    #structure of pixelPosition [x position within square, y position within square]

    pointsEvaluated = 4
    listDotProducts = []

    for pointNumber in range(pointsEvaluated):
        #pointX = pointPositions[pointNumber][0][0] * resolution + 0.5
        #pointY = pointPositions[pointNumber][0][1] * resolution + 0.5
        pointVectorX = pointPositions[pointNumber][1][0]
        pointVectorY = pointPositions[pointNumber][1][1]
        #find the point and vector associated with the corner

        distanceToLeft = pixelPosition[0]
        distanceToRight = distanceToLeft - 1.0
        distanceToBottom = pixelPosition[1]
        distanceToTop = distanceToBottom - 1.0

        if pointNumber == 0: #bottomLeft
            secondaryVectorX = distanceToLeft
            secondaryVectorY = distanceToBottom
        elif pointNumber == 1: #topLeft
            secondaryVectorX = distanceToLeft
            secondaryVectorY = distanceToTop
        elif pointNumber == 2: #bottomRight
            secondaryVectorX = distanceToRight
            secondaryVectorY = distanceToBottom
        elif pointNumber == 3: #topRight
            secondaryVectorX = distanceToRight
            secondaryVectorY = distanceToTop
        
        #generate secondary vector magnitudes by finding difference between pixel and point, then scale to be maximum length of root 2

        xDotProduct = pointVectorX * secondaryVectorX
        yDotProduct = pointVectorY * secondaryVectorY 
        totalDotProduct = xDotProduct + yDotProduct
        listDotProducts.append(totalDotProduct)
    
    vBottom = lerp(listDotProducts[0], listDotProducts[2], smooth(distanceToLeft))
    vTop = lerp(listDotProducts[1], listDotProducts[3], smooth(distanceToLeft))

    finalValue = lerp(vBottom, vTop , smooth(distanceToBottom))

    #print(finalValue)
    #assert finalValue >= 0.0 and finalValue <= 1.0

    return finalValue + 0.5
    #value between 0 and 1

def pointGeneration(xCount : int, yCount : int):
    spacingX = 1 / (xCount - 1)
    spacingY = 1 / (yCount - 1)

    pointCoords = np.zeros((xCount,yCount,2), dtype=float) 
    #initialise the list

    for x in range(xCount):
        for y in range(yCount):
            pointCoords[x,y] = [(x * spacingX), (y * spacingY)]
    #generate X points and duplicate Y times
    
    return pointCoords

def vectorGeneration(xCount : int, yCount : int, seed : int):
    pointVectors = np.zeros((xCount,yCount,2), dtype=float) 
    #initialise the list

    rng = np.random.default_rng(seed)
    #seed the random function

    for x in range(xCount):
        for y in range(yCount):
            angle = rng.random() * 2 * math.pi 
            #generate a value between 0 and 2pi radians

            pointVectors[x,y] = [math.cos(angle), math.sin(angle)]

            #testing functions, remove when done
            #pointVectors[x,y] = [math.sqrt(2)/2, math.sqrt(2)/2]
            #pointVectors[x,y] = [1, 0]
            #if x == 1 and y == 1:
                #pass
                #pointVectors[x,y] = [-1,0]
            #convert to cartesian and assign

    #return list of cartesian magnitudes [x magnitude, y magnitude]
    return pointVectors

def pointInfo(xPixel : int, yPixel : int, pointCoords, xCount : int, yCount : int, resolution, pointVectors):
    #nearestPoints uses the 0-1 coordinate system
    xPosition = (xPixel + 0.5)/ resolution
    yPosition = (yPixel + 0.5)/ resolution
    #divide to turn pixel coordinate to grid coordinate
    assert xPosition <= 1 and xPosition >= 0
    assert yPosition <= 1 and yPosition >= 0

    spacingX = 1 / (xCount - 1)
    spacingY = 1 / (yCount - 1)

    gridX = int(xPosition // spacingX)
    gridY = int(yPosition // spacingY)
    #find which box the pixel is in

    xPos = (xPosition / spacingX) % 1
    yPos = (yPosition / spacingY) % 1

    assert gridX <= xCount
    assert gridY <= yCount

    #print(gridX,"\n", gridY)

    bottomLeft = [pointCoords[gridX][gridY], pointVectors[gridX][gridY]]
    topLeft = [pointCoords[gridX][gridY + 1], pointVectors[gridX][gridY + 1]]
    bottomRight = [pointCoords[gridX + 1][gridY], pointVectors[gridX + 1][gridY]]
    topRight = [pointCoords[gridX + 1][gridY + 1], pointVectors[gridX + 1][gridY + 1]]
    #find the points and vectors associated with the grid intersections

    return [bottomLeft, topLeft, bottomRight, topRight], [xPos, yPos] 
    #returns a list of vectors, [xpos,ypos],[xmag,ymag]

def perlinNoise(xCount : int, yCount : int, seed : int, resolution : int):

    pointCoords = pointGeneration(xCount, yCount)
    #structure [x position, y position]
    pointVectors = vectorGeneration(xCount, yCount, seed)
    #structure [x magnitude, y magnitude]
    #print("done 1!")
    bitmap = np.zeros((resolution,resolution), dtype = float)

    for xPixel in range(resolution):
        if xPixel % 100 == 0:
            print(xPixel)
        for yPixel in range(resolution):
            
            #print(f"Pixel: ({xPixel},{yPixel})") #debug print

            pointPositions, pixelPosition = pointInfo(xPixel, yPixel, pointCoords, xCount, yCount, resolution, pointVectors)
            #find nearest points

            value = perlinPixel(xPixel, yPixel, pointPositions, pixelPosition)
            #run perlin noise
            #print(f"Value of pixel: {value}") #debug print

            bitmap[xPixel, yPixel] = value
    print(f"Max: {bitmap.max()}\nMin: {bitmap.min()}")
    return bitmap


#gridRandomisation = 0 #GUI slider between 0 and 1
xCount = 11 #integer gui slider between 1 and 200
yCount = 11 #integer gui slider between 1 and 200
seed = 0 #integer text box - possibility of adding hash functionality
resolution = 1000 #integer for image width and height
#option of adding a black level and a white level

bitmap = perlinNoise(xCount, yCount, seed, resolution)
#print("done perlin")
renderedImage = Image.new('L', (resolution,resolution))
#L for greyscale, RGB for RGB, HSV for HSV   
    
for xIterations in range(resolution):
    for yIterations in range(resolution):        
        try:
            pixelValue = int(255*bitmap[xIterations,yIterations])
            assert pixelValue >= 0 and pixelValue <= 255
        except:
            pixelValue = 0
        renderedImage.putpixel((xIterations,yIterations),pixelValue)
    
renderedImage.save("Perlin44.png")
print("done!")

"""
#t1 = perf_counter()
pointCoords = pointGeneration(xCount, yCount)
#t2 = perf_counter()
pointVectors = vectorGeneration(xCount, yCount, seed)
#t3 = perf_counter()
#print((t2-t1),"s")
#print((t3-t2),"s")

xcoords = []
ycoords = []
xMags = []
yMags = []

for x in range(pointCoords.shape[0]):
    for y in range(pointCoords.shape[1]):
        xcoords.append(pointCoords[x,y,0])
        ycoords.append(pointCoords[x,y,1])
        xMags.append(pointVectors[x,y,0])
        yMags.append(pointVectors[x,y,1])


#print("xvalues", array[0], "\n", "yvalues", array[1] )

plt.scatter(xcoords,ycoords)
#plt.quiver(xcoords,ycoords, xMags, yMags)
plt.show()
"""
