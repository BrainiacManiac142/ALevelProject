import numpy as np
import matplotlib.pyplot as plt
import math
from time import perf_counter
from numba import cuda
from PyQt5.QtGui import QPixmap, QImage, qRgb
from PyQt5.QtWidgets import QMainWindow, QApplication, QLabel

import os
os.environ['NUMBAPRO_LIBDEVICE'] = r"C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.6\nvvm\libdevice"
os.environ['NUMBAPRO_NVVM'] = r"C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.6\nvvm\bin\nvvm64_40_0.dll"

@cuda.jit
def lerp(a : float, b : float, c : float):
    #assert c >= 0 and c <= 1
    return float((b - a) * c + a)

@cuda.jit
def smooth(v):
    #assert v >= 0 and v <= 1
    outputValue = v * v * v * (6 * v * v - 15 * v + 10 )
    #assert outputValue <= 1 and outputValue >= 0
    return outputValue

def rescale(bitmap):
    maxValue = bitmap.max()
    minValue = bitmap.min()
    #Find the lowest and highest pixel values

    valueRange = maxValue - minValue
    rescaledBitmap = (bitmap - minValue) * (1/valueRange)
    #compress or expand it so every pixel lies between 0 and 1

    return rescaledBitmap

def vectorGeneration(xCount : int, yCount : int, seed : int):
    pointVectors = np.zeros((xCount,yCount,2), dtype=float) 
    #initialise the list

    rng = np.random.default_rng(seed)
    #seed the random function

    for x in range(xCount):
        for y in range(yCount):
            angle = rng.random() * 2 * math.pi 
            #generate a value between 0 and 2pi radians

            pointVectors[x,y] = [math.cos(angle), math.sin(angle)]

            #testing functions, remove when done
            #pointVectors[x,y] = [math.sqrt(2)/2, math.sqrt(2)/2]
            #pointVectors[x,y] = [1, 0]
            #if x == 1 and y == 1:
                #pass
                #pointVectors[x,y] = [-1,0]
            #convert to cartesian and assign

    #return list of cartesian magnitudes [x magnitude, y magnitude]
    return pointVectors

def valueGeneration(xCount : int, yCount : int, seed : int):

    pointValues = np.zeros((xCount,yCount), dtype=float) 
    #initialise the list

    rng = np.random.default_rng(seed)
    #seed the random function

    for x in range(xCount):
        for y in range(yCount):
            #generate a value between 0 and 1

            pointValues[x,y] = rng.random()
    
    return pointValues

def pointGeneration(gridRandomisation, xCount : int, yCount : int, seed : int):

    spacingX = 1 / xCount
    spacingY = 1 / yCount

    pointCoords = np.zeros((xCount,yCount,2), dtype=float) 
    #initialise the list

    for x in range(xCount):
        for y in range(yCount):
            pointCoords[x,y] = [((x+0.5) * spacingX), ((y+0.5) * spacingY)]
    #generate X points and duplicate Y times
    
    if gridRandomisation == 0:
        return pointCoords

    rng = np.random.default_rng(seed) # seed the random fucntion
    
    #randomise points
    for x in range(xCount):
        for y in range(yCount):
            pointCoords[x,y,0] += ((rng.random() * 2) - 1) * gridRandomisation * spacingX 
            pointCoords[x,y,1] += ((rng.random() * 2) - 1) * gridRandomisation * spacingY 
            #multiplying by 2 and subtracting 1 increases the span of the float generator from 0-1 to -1 - 1 

    #iterate through every coordinate and randomise XY

    return pointCoords

def nearestPoint(xPixel : int, yPixel : int, pointCoords, xCount : int, yCount : int, resolution, pointValues):

    #print(pointValues)
    #nearestPoints uses the 0-1 coordinate system
    xPosition = xPixel/ resolution
    yPosition = yPixel / resolution
    #divide to turn pixel coordinate to grid coordinate

    spacingX = 1 / xCount
    spacingY = 1 / yCount

    gridX = int(xPosition // spacingX)
    gridY = int(yPosition // spacingY)
    #find which box the pixel is in
    
    pointDistance = []

    for x in range(-1 , 2):
        for y in range(-1, 2):
            try:
                testX = int(gridX + x)
                testY = int(gridY + y)
                #which grid box is being analysed

                point = pointCoords[testX][testY]
                #find the x and y value of the point within the box
                value = pointValues[testX][testY]
                #find the value assigned to it

                xDistance = (point[0] - xPosition)
                yDistance = (point[1] - yPosition)

                totalDistance = (xDistance * xDistance) + (yDistance * yDistance )#no need to square root it as the distance is comparative

                pointDistance.append([totalDistance, value])
            except:
                #print(f"Exception at: {testX}, {testY}")
                pass
    
    
    #pointDistance.sort()
    sortedDistances = sorted(pointDistance, key = lambda x : x[0])

    return sortedDistances[0] #returns distance and value of the closest point

def pixelCalc(xPixel : int, yPixel : int, xCount : int, yCount : int, resolution, pointVectors):

    xPosition = (xPixel + 0.5)/ resolution
    yPosition = (yPixel + 0.5)/ resolution
    #divide to turn pixel coordinate to grid coordinate

    #assert xPosition <= 1 and xPosition >= 0
    #assert yPosition <= 1 and yPosition >= 0

    spacingX = 1 / (xCount - 1)
    spacingY = 1 / (yCount - 1)

    gridX = int(xPosition // spacingX)
    gridY = int(yPosition // spacingY)
    #find which box the pixel is in

    distanceToLeft = (xPosition / spacingX) % 1
    distanceToBottom  = (yPosition / spacingY) % 1
    #find where within the box the pixel is

    distanceToRight = distanceToLeft - 1.0
    distanceToTop = distanceToBottom - 1.0
    #derive other 2 distances

    #assert gridX <= xCount
    #assert gridY <= yCount

    #perlinpixel uses the pixel based coordinate system
    #structure of pointPositions: [x position, y position],[x magnitude, y magnitude]
    #structure of pixelPosition [x position within square, y position within square]

    #BottomLeft
    pointVectorX = pointVectors[gridX][gridY][0]
    pointVectorY = pointVectors[gridX][gridY][1]
    secondaryVectorX = distanceToLeft
    secondaryVectorY = distanceToBottom
    bottomLeftDotProduct = ((pointVectorX * secondaryVectorX) + (pointVectorY * secondaryVectorY))

    #topleft
    pointVectorX = pointVectors[gridX][gridY + 1][0]
    pointVectorY = pointVectors[gridX][gridY + 1][1]
    secondaryVectorX = distanceToLeft
    secondaryVectorY = distanceToTop
    topLeftDotProduct = ((pointVectorX * secondaryVectorX) + (pointVectorY * secondaryVectorY))
    
    #bottomRight
    pointVectorX = pointVectors[gridX + 1][gridY][0]
    pointVectorY = pointVectors[gridX + 1][gridY][1]
    secondaryVectorX = distanceToRight
    secondaryVectorY = distanceToBottom
    bottomRightDotProduct = ((pointVectorX * secondaryVectorX) + (pointVectorY * secondaryVectorY))

    #topRight
    pointVectorX = pointVectors[gridX + 1][gridY + 1][0]
    pointVectorY = pointVectors[gridX + 1][gridY + 1][1]
    secondaryVectorX = distanceToRight
    secondaryVectorY = distanceToTop
    topRightDotProduct = ((pointVectorX * secondaryVectorX) + (pointVectorY * secondaryVectorY))
    
    lerpBottom = lerp(bottomLeftDotProduct, bottomRightDotProduct, smooth(distanceToLeft))
    lerpTop = lerp(topLeftDotProduct, topRightDotProduct, smooth(distanceToLeft))
    finalValue = lerp(lerpBottom, lerpTop , smooth(distanceToBottom)) 
    #bilinear interpolation within the grid cell

    return finalValue

@cuda.jit
def GPUPerlinPixel(xCount, yCount, resolution, pointVectors, bitmap):
    xPixel, yPixel = cuda.grid(2)
    #returns the x and y 
    if xPixel < resolution and yPixel < resolution:
        xPosition = (xPixel + 0.5)/ resolution
        yPosition = (yPixel + 0.5)/ resolution
        #divide to turn pixel coordinate to grid coordinate

        #assert xPosition <= 1 and xPosition >= 0
        #assert yPosition <= 1 and yPosition >= 0

        spacingX = 1 / (xCount - 1)
        spacingY = 1 / (yCount - 1)

        gridX = int(xPosition // spacingX)
        gridY = int(yPosition // spacingY)
        #find which box the pixel is in

        distanceToLeft = (xPosition / spacingX) % 1
        distanceToBottom  = (yPosition / spacingY) % 1
        #find where within the box the pixel is

        distanceToRight = distanceToLeft - 1.0
        distanceToTop = distanceToBottom - 1.0
        #derive other 2 distances

        #assert gridX <= xCount
        #assert gridY <= yCount

        #perlinpixel uses the pixel based coordinate system
        #structure of pointPositions: [x position, y position],[x magnitude, y magnitude]
        #structure of pixelPosition [x position within square, y position within square]

        #BottomLeft
        pointVectorX = pointVectors[gridX][gridY][0]
        pointVectorY = pointVectors[gridX][gridY][1]
        secondaryVectorX = distanceToLeft
        secondaryVectorY = distanceToBottom
        bottomLeftDotProduct = ((pointVectorX * secondaryVectorX) + (pointVectorY * secondaryVectorY))

        #topleft
        pointVectorX = pointVectors[gridX][gridY + 1][0]
        pointVectorY = pointVectors[gridX][gridY + 1][1]
        secondaryVectorX = distanceToLeft
        secondaryVectorY = distanceToTop
        topLeftDotProduct = ((pointVectorX * secondaryVectorX) + (pointVectorY * secondaryVectorY))
        
        #bottomRight
        pointVectorX = pointVectors[gridX + 1][gridY][0]
        pointVectorY = pointVectors[gridX + 1][gridY][1]
        secondaryVectorX = distanceToRight
        secondaryVectorY = distanceToBottom
        bottomRightDotProduct = ((pointVectorX * secondaryVectorX) + (pointVectorY * secondaryVectorY))

        #topRight
        pointVectorX = pointVectors[gridX + 1][gridY + 1][0]
        pointVectorY = pointVectors[gridX + 1][gridY + 1][1]
        secondaryVectorX = distanceToRight
        secondaryVectorY = distanceToTop
        topRightDotProduct = ((pointVectorX * secondaryVectorX) + (pointVectorY * secondaryVectorY))
        
        lerpBottom = lerp(bottomLeftDotProduct, bottomRightDotProduct, smooth(distanceToLeft))
        lerpTop = lerp(topLeftDotProduct, topRightDotProduct, smooth(distanceToLeft))
        finalValue = lerp(lerpBottom, lerpTop , smooth(distanceToBottom)) 
        #bilinear interpolation within the grid cell

        bitmap[xPixel, yPixel] = finalValue

def perlinNoise(xCount : int, yCount : int, seed : int, resolution : int):
    #pointCoords = pointGeneration(xCount, yCount)
    #structure [x position, y position]
    pointVectors = vectorGeneration(xCount, yCount, seed)
    #structure [x magnitude, y magnitude]
    #print("done 1!")
    bitmap = np.zeros((resolution,resolution), dtype = float)

    CPU = False

    if CPU == True:
        for xPixel in range(resolution):
            if xPixel % 100 == 0:
                print(xPixel)
            for yPixel in range(resolution):
                
                #print(f"Pixel: ({xPixel},{yPixel})") #debug print

                value = pixelCalc(xPixel, yPixel, xCount, yCount, resolution, pointVectors)

                #run perlin noise
                #print(f"Value of pixel: {value}") #debug print

                bitmap[xPixel, yPixel] = value
    else:
        devicePointVectors = cuda.to_device(pointVectors)
        deviceBitmap = cuda.to_device(bitmap)
        blockWidth = 16
        blockCount = int(resolution/blockWidth) + 1

        GPUPerlinPixel[(blockCount, blockCount), (blockWidth, blockWidth)](xCount, yCount, resolution, devicePointVectors, deviceBitmap)
        cuda.synchronize()
        #wait until the previous function has finished

        #pointVectors = devicePointVectors.copy_to_host()
        bitmap = deviceBitmap.copy_to_host()
        #retrieve the gata from the device

    #print(f"Max: {bitmap.max()}\nMin: {bitmap.min()}")

    rescaledBitmap = rescale(bitmap)

    return rescaledBitmap

def voronoiNoise(xCount : int, yCount : int, seed : int, resolution : int, gridRandomisation):
    pointCoords = pointGeneration(gridRandomisation, xCount, yCount, seed)
    #structure [x position, y position]
    pointValues = valueGeneration(xCount, yCount, seed)
    #structure [value]
    #print("done 1!")
    bitmap = np.zeros((resolution,resolution), dtype = float)

    for xPixel in range(resolution):
        if xPixel % 100 == 0:
            print(xPixel)
        for yPixel in range(resolution):
            
            #print(f"Pixel: ({xPixel},{yPixel})") #debug print

            closestPoint = nearestPoint(xPixel, yPixel, pointCoords, xCount, yCount, resolution, pointValues)

            value = closestPoint[1]

            #run perlin noise
            #print(f"Value of pixel: {value}") #debug print

            bitmap[xPixel, yPixel] = value

        #retrieve the gata from the device

    #print(f"Max: {bitmap.max()}\nMin: {bitmap.min()}")

    rescaledBitmap = rescale(bitmap)

    return rescaledBitmap

def output(bitmap, resolution):
    t1 = perf_counter()
    rgbMap = np.uint8(bitmap * 255)
    t2 = perf_counter()
    qImg = QImage( rgbMap.data, resolution, resolution, QImage.Format_Grayscale8)
    t3 = perf_counter()
    #Format_RGB32
    #Grayscale16
    qImg.save("Perlin65.png")
    t4 = perf_counter()

    print(f"1: {round(t2 - t1, 3)}s \n2: {round(t3 - t2, 3)}s \n3: {round(t4 - t3, 3)}s")

startTime = perf_counter()
xCount = 50 #integer gui slider between 1 and 200
yCount = 50 #integer gui slider between 1 and 200
seed = 1 #integer text box - possibility of adding hash functionality
resolution = 16000 #integer for image width and height
bitDepth = 8
#option of adding a black level and a white level

bitmap = perlinNoise(xCount, yCount, seed, resolution)

perlinDone = perf_counter()

output(bitmap, resolution)
#print("done perlin")

final = perf_counter()

print(f"Perlin: {round(perlinDone - startTime, 3)}s \nImage Processing: {round(final - perlinDone, 3)}s \nTotal: {round(final- startTime, 3)}s")


"""
plt.hist(allValues, bins=np.arange(0, 255))
plt.show()
print("done2")
"""

